http://memcached.org/

Memcached是一个高性能、分布式的内存对象缓存系统。

Memcached的作用是通过缓存数据库查询结果，减少数据库负载。 

### 什么是缓存

应用程序将数据保存到MySQL这样的关系型数据库中，用户访问数据库从中读取数据。数据库的数据是保存在硬盘中的， 随着数据量的增大、QPS提高，就会出现数据库的负载加重、读取数据的速度降低。

为了解决这个问题，引入缓存，将使用频繁的数据放在内存中，用户不直接访问数据库，从而提高效率。

![web_6](http://www.runoob.com/wp-content/uploads/2015/08/web_6.jpg)

引入缓存后的读取数据的顺序：

- 第一步，从缓存读取数据，如果有数据，直接返回数据;
- 第二步，从DB读取数据，保存到缓存，返回数据。

缓存可以认为是数据的池，这些数据是从数据库里的真实数据复制出来的，并且为了能别取回，被标上了标签（键 ID）。通过缓存数据库查询结果，减少数据库访问次数。redis、memcached是常用的分布式缓存系统。

### 缓存特征

缓存也是一个数据模型对象，那么必然有它的一些特征：

**命中(Cache Hits)**

用户发起一个请求，应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取。

如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用，这叫做缓存命中。

**未命中(Cache Miss)**

１. 如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。

２. 如果缓存满了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为替代策略（缓存算法），这些策略会决定到底应该提出哪些对象。

![img](http://jbcdn2.b0.upaiyun.com/2012/12/caching.jpg)

**命中率**

命中率=返回正确结果数/请求缓存次数，命中率问题是缓存中的一个非常重要的问题，它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高。

**最大元素（或最大空间）**

缓存中可以存放的最大元素的数量，一旦缓存中元素数量超过这个值（或者缓存数据所占空间超过其最大支持空间），将会触发删除策略，根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存。

**存储成本**

当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。

**失效**

当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。

**删除策略**

当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中踢出一个老的条目，加入一条新的条目，而到底应该踢出什么条目，就由替代策略决定。设计适合自身数据特征的删除策略能有效提升命中率。常见的一般策略有：

- **FIFO(first in first out)**

  先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。

- **LFU(less frequently used)**

  最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。

- **LRU(least recently used)**

  最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。

除此之外，还有一些简单策略比如：

- 根据过期时间判断，清理过期时间最长的元素；
- 根据过期时间判断，清理最近要过期的元素；
- 随机清理；
- 根据关键字（或元素内容）长短清理等。


**最优替代策略**

最优的替代策略就是想把缓存中最没用的条目给踢出去，但是未来是不能够被预知的，所以这种策略是不可能实现的。但是有很多策略，都是朝着这个目前去努力。

### 缓存分类

缓存数据分布：

| 分布    | 使用场景    | 优点                    | 缺点               | 代表例子                                     |
| ----- | ------- | --------------------- | ---------------- | ---------------------------------------- |
| 本地缓存  | 数据变化率较低 | 存储任意数据，无网络存取延迟，数据查询更快 | 占用应用系统资源，容量和伸缩性差 | HashMap、GuavaCache、OSCache、JCache、Ehcache |
| 分布式缓存 | 数据变化率较高 | 容量和伸缩性好               | 网络开销大，响应时间长      | Memcached、Redis、Tair                     |

数据存储方式：

| 模式      | 特点                    | 运维复杂度 | 代表例子       |
| ------- | --------------------- | ----- | ---------- |
| 内存模式    | 所有数据内存Cache           | 相对较低  | Memcached  |
| 磁盘持久化模式 | 热点数据内存Cache，非热点数据磁盘存储 | 高     | Redis、Tair |


### Memcached介绍

Memcached是分布式的内存对象缓存系统，采用C/S模式。

Memcached 通过C语言实现，采用了单进程，单线程，异步I/O，基于事件 (event-based) 的服务方式。使用libevent 作为事件通知。

Memcached本身并不是分布式的。memcached集群环境实际就是一个个memcached服务器的堆积，多个 Server 可以协同工作，但这些 Server 之间是没有任何通信，每个 Server 只是对自己的数据进行管理。

分布式是由客户端实现的，客户端通过路由算法来达到分布式的目的。应用服务器在每次存取数据时，通过路由算法把key映射到一台memcached服务器上，因此这个key所有操作都在这台服务器上。只要服务器还缓存着该数据，就能保证缓存命中。 

缓存的对象或数据是以 key-value对的形式保存在Server端的内存中。key 的值通过 hash 进行转换，根据 hash 值把 value 传递到对应的具体的某个 Server 上。当需要获取对象数据时，也根据 key 进行。首先对 key 进行 hash，通过获得的值可以确定它被保存在了哪台 Server 上，然后再向该 Server 发出请求。Client 端只需要知道保存 hash(key) 的值在哪台服务器上就可以了。

因此，memcache 的工作就是在专门的机器的内存里维护一张巨大的 hash 表，来存储经常被访问的一些数据。

![Memcached访问模型](https://upload-images.jianshu.io/upload_images/6060459-cb410114782e3e39.png?imageMogr2/auto-orient/)



### Memcached的特性

- 协议简单

Memcached支持文本和二进制协议；
文本协议调试简单，内容可视化；
二进制性能高效，且相对文本协议安全性高。

- 基于libevent的事件处理

使用IO多路复用的IO模型，Linux系统下使用epoll处理数据读写，具备极高的IO性能。

- 内置内存存储方式

所有数据存放在内存，相对于Linux提供的malloc/free产生的内存碎片，Memcached独特的内存存储方式可以避免内存碎片，提高内存利用率和性能。
因为数据存储在内存中，所以重启Memcached和操作系统，数据将全部丢失。

- Memcached互不通信的分布式

Memcached实际上不是一个真正的分布式服务器，集群的各个Memcached服务器不互相通信以共享数据，分布式特性通过客户端实现。实际上这也避免分布式集群特有的问题：脑裂。